import os
import csv
import pandas as pd
from sklearn.feature_extraction import DictVectorizer
import matplotlib.pyplot as plt
from sklearn.manifold import TSNE
from sklearn.decomposition import PCA
import json
from sklearn.cluster import KMeans

dirname = 'geek/phase1/trace2_test'
fileMap = {
    'fqdn':os.path.join(dirname,'fqdn_ip.csv'),
    'email':os.path.join(dirname,'trojan_email.csv'),
    'phone':os.path.join(dirname,'trojan_phone.csv'),
    'web':os.path.join(dirname,'trojan_web.csv'),
    'region':os.path.join(dirname,'fqdn_reginfo.csv'),
}
graphFile = 'graph.txt'
clusterFile = 'trace2.csv'

searchGraphFile = 'geek/code/graph/searchNode.json'
filterFile = 'geek/phase1/trace1_test/trace2.csv'
def line2data(line):
    return line.strip().split(',')

def readFile(filename):        
    dataList = []
    inf = open(filename,encoding='utf-8')
    reader = csv.reader(inf)
    keys = next(reader)
    keys[0] = 'sha1'
    for row in reader:
        newData = {}
        for i in range(len(keys)):
            newData[keys[i]] = row[i]           
        dataList.append(newData)
    return dataList



def clusterFromDir():
    graphs = set()
    # for data in readFile(fileMap['web']):
    #     sha = data['sha1']
    #     url = data['url']
    #     vals = url.split('/')
    #     domain = '.'.join(vals[2].split('.')[-2:])
    #     filename = vals[-1]
    #     graphs.add('%s,%s,%s\n'%(sha,domain,'domain'))
        # graphs.add('%s,%s,%s\n'%(sha,filename,'filename'))
    for word in ['email','phone']:
        filename = fileMap[word]
        for data in readFile(filename):
            node1 = data['sha1']
            for key in data:
                if key == 'sha1':
                    continue                
                node2 = data[key]
                if len(node2)>0:    
                    graph = '%s,%s,%s\n'%(node1,node2,word)                
                    graphs.add(graph)
                    # if node2 not in pointMap:
                    #     pointMap[node2] = set()
                    # pointMap[node2].add(node1)
    # for key in sorted(pointMap,key=lambda x:len(pointMap[x]),reverse=True)[:50]:
    #     print(key,len(pointMap[key]))    
    with open('graph.txt','a+') as outf:    
        outf.writelines(list(graphs))

                
def clusterFromNode2Vec():
    shaList = {}
    for filename in [ipfile,email,region,'phone','web']:
        with open(filename) as inf:
            inf.readline()
            for line in inf.readlines():
                sha = line.split(',')[0]
                if sha not in shaList:
                    shaList[sha] = []
    with open('geek/phase1/trace2_test/vec_all.txt') as inf:        
        featureLen = int(inf.readline().split(' ')[1].strip())
        for line in inf.readlines():
            vals = line.split(' ')
            key = vals[0]
            if key in shaList:
                for val in vals[1:]:
                    shaList[key].append(float(val))
        v = DictVectorizer()
    plt.figure(figsize=(12, 12))
    shaL = list(shaList.keys())
    X = list(shaList.values())
    random_state = 170
    model = KMeans(n_clusters=10000)
    y = model.fit_predict(X)    
    print(pd.Series(model.labels_).value_counts())
    print(pd.DataFrame(model.cluster_centers_))
    
    outf = open('trace2.csv','w+')
    for i in range(len(shaL)):
        outf.write('%s,%d\n'%(shaL[i],y[i]))

    pca = PCA()
    data = pd.DataFrame(X)
    data =pca.fit_transform(data)
    data = pd.DataFrame(data,index=X.index)

#   need to debug
#   tsne = TSNE(learning_rate=100)
#   tsne.fit_transform(X)
#   data =pd.DataFrame(tsne.embedding_, index=X.index)
 
#   不同类别用不同颜色和样式绘图
    # d = data[model.labels_==0]
    # plt.plot(d[0],d[1],'r.')
    # d = data[model.labels_==1]
    # plt.plot(d[0],d[1],'go')
    # d = data[model.labels_==2]
    # plt.plot(d[0],d[1],'b*')
    # plt.show()


def graph2family(filename):
    graphMap = {}
    hashMap = {}
    fatherMap = {}
    index =0
    for line in open(filename).readlines():
        vals = line.split(',')
        familyID = index
        childID = index
        for key in vals:
            if key in graphMap:
                familyID = min(familyID,graphMap[key])
                childID = max(familyID,graphMap[key])
        graphMap[vals[0]] = familyID
        graphMap[vals[1]] = familyID
        hashMap[vals[0]] = familyID
        fatherMap[childID] = familyID
        if familyID==index:
            index+=1
    outf = open('trace2.csv','w+')
    for key in fatherMap:
        family = fatherMap[key]
        while family!=fatherMap[family]:
            family = fatherMap[family]
        fatherMap[key] = family
    print(len(set(fatherMap.values())))
    for key in hashMap:
        outf.write('%s,%d\n'%(key,fatherMap[hashMap[key]]))

def readClusterMap():
    hashMap = {}
    familyMap = {}
    with open(clusterFile) as inf:
        for line in inf.readlines():
            vals = line.split(',')
            sha = vals[0]
            family = vals[1]
            hashMap[sha] = family
            if family not in familyMap:
                familyMap[family] = []
            familyMap[family].append(sha)
    return hashMap,familyMap

def searchGraph(node):
    hashMap,familyMap = readClusterMap()
    checkNode = familyMap[hashMap[node]]
    dstList = {}
    result = []
    with open(filterFile,'w+') as outf:
        for sha in checkNode:
            outf.write('%s,%d\n'%(sha,1))

    for line in open(graphFile).readlines():
        vals = line.strip().split(',')
        if vals[0] in checkNode:
            result.append([vals[0],vals[1],vals[2]])
            if vals[1] not in dstList:
                dstList[vals[1]] = 0
            dstList[vals[1]] +=1
    print(sorted(dstList.items(),key=lambda x:x[1],reverse=True)[:30])
    print(len(checkNode))

    # print(result)
    with open(searchGraphFile,'w+') as outf:
        json.dump(result,outf)

 
if __name__=='__main__':
    clusterFromDir()
    # clusterFromDGA()
    graph2family('graph.txt')
    # searchGraph('3f9cbee439ab0f9893d7c9076b5c8c474917eec4')
    
    # cluster()
    # culstterTest('geek/phase1/trace2_test')
    