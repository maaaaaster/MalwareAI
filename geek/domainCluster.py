from cluster import fileMap,readFile,clusterFile,graphFile,readClusterMap
from sklearn.feature_extraction import DictVectorizer
from sklearn.cluster import KMeans
import pandas as pd
import re
domainShaMap = {}
domainFileMap = {}
shaDomainMap = {}
secondDomainMap = {}
DomianClassification = {}
domainIpmap = {}
whiteList = ['baidupan.com','t.cn','ctyunapi.cn','dwz.cn','']
def checkip(ip):  
    p = re.compile('^((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$')  
    if p.match(ip):  
        return True  
    else:  
        return False  

for data in readFile(fileMap['fqdn']):
    sha = data['sha1']
    url = data['site']
    ip = data['ip']
    if url not in domainIpmap:
        domainIpmap[url] = set()
    domainIpmap[url].add(ip)

for data in readFile(fileMap['web']):
    sha = data['sha1']
    url = data['url']
    vals = url.split('/')
    fulldomain = vals[2].split(':')[0]       
    if checkip(fulldomain):
        DomianClassification[fulldomain] = 'ip'
        continue
    filename = vals[-1]
    if fulldomain not in domainFileMap:
        domainFileMap[fulldomain] = set()
    domainFileMap[fulldomain].add(filename)
    if fulldomain not in domainShaMap:
        domainShaMap[fulldomain] = set()
    domainShaMap[fulldomain].add(sha)
    if sha not in shaDomainMap:
        shaDomainMap[sha] = set()
    shaDomainMap[sha].add(fulldomain)
    vals = fulldomain.split('.')
    secondDomain = '.'.join(vals[-2:])
    if secondDomain not in secondDomainMap:
        secondDomainMap[secondDomain] = set()
    secondDomainMap[secondDomain].add(fulldomain)

# for key,val in sorted(secondDomainMap.items(),key=lambda x:len(x[1]),reverse=True)[-30:]:
#     print(key,len(val))




def makeDGASet(domainIpmap,domainShaMap,shaDomainMap):
    dgaSet = set()
    for domain in domainShaMap:
        if domain not in domainIpmap:
            dgaSet.add(domain)
    nextDga = set()
    for domain in dgaSet:
        for sha in domainShaMap[domain]:
            for nextDomain in shaDomainMap[sha]:
                nextDga.add(nextDomain)
    dgaSet = dgaSet | nextDga
    return dgaSet

dgaSet = makeDGASet(domainIpmap,domainShaMap,shaDomainMap)

trainData = []
for domain in domainShaMap:
    vals = domain.split('.')
    isDGA = domain in dgaSet
    secondDomain = '.'.join(vals[-2:])
    secondDomainNum = len(secondDomainMap[secondDomain])
    trainData.append({
        'domain':domain,
        'filecount':len(domainShaMap[domain]),
        'enddomain':vals[-1],
        'seconddomain':vals[-2],
        'block':len(vals),
        'domainLen':len(domain),
        'secondDomainMap':secondDomainNum,
        'domainFileLen':len(domainShaMap[domain]),
        'ipNum':0 if isDGA else len(domainIpmap[domain]),
        'isdga':isDGA
    })

X = pd.DataFrame(trainData)

# toCheck = X[X['isdga']]
# for x in toCheck[toCheck['block']>2].groupby('seconddomain'):
#     print(x[1])
def filterByDGA():
    hashMap,familyMap = readClusterMap()
    checkedFamily = set()
    outf = open('trace2_dga.csv','w+')

    for family in familyMap:
        nodes = familyMap[family]
        domainSet = set()
        isDGA = False
        for sha in nodes:
            if sha not in shaDomainMap:
                continue
            for domain in shaDomainMap[sha]:
                domainSet.add(domain)
                isDGA = isDGA or domain in dgaSet
        if isDGA and len(domainSet)>50:
            print(family,domainSet)
            for sha in nodes:
                outf.write('%s,%s'%(sha,family))



    # for line in open(graphFile).readlines():
    #     vals = line.strip().split(',')
    #     sha = vals[0]
    #     domain = vals[1]
    #     family = hashMap[sha]
    #     if domain in dgaSet and family not in checkedFamily:
    #         checkedFamily.add(family)
    #         domainSet = set()
    #         shaList = familyMap[family]
    #         for shaVal in shaList:
    #             if shaVal not in shaDomainMap:
    #                 continue
    #             for nxDomain in shaDomainMap[shaVal]:
    #                 domainSet.add(nxDomain)
    #         print(family,domainSet)

filterByDGA()
                

            



# toCheck = X[X['isdga']]
# for x in toCheck[toCheck['block']>2].groupby('seconddomain'):
#     print(x[1])

# print(X[(X['isdga']) & (X['secondDomainMap']>1)])
# toCheck = X[(X['secondDomainMap']==1) & (X['domainFileLen']>1) & (X['ipNum']>1) ]
# X[(X['secondDomainMap']==1) & (X['domainFileLen']>10) & (X['ipNum']>10) ]
# print(toCheck[toCheck['ipNum']>4])


# model = KMeans(n_clusters=100)
# y = model.fit_predict(X)   
