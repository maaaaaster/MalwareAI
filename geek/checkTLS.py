import pandas as pd
import os
from sklearn.feature_extraction import DictVectorizer
# from sklearn.model_selection import data_test_split 
from sklearn.model_selection import train_test_split
from sklearn.metrics import roc_auc_score
from sklearn.metrics import accuracy_score 
import lightgbm as lgb 
from datetime import datetime
from sklearn.externals import joblib
from sklearn import metrics
def loadTrain():
    data = pd.read_csv('data.csv')
    print('raw_data has %d white and %d black'%(len(data[data['label']=='white']),len(data[data['label']=='black'])))
    tsinghuadir='/home/eta/tsinghua/'
    data_tsinghua = pd.concat(
        [pd.read_csv(os.path.join(tsinghuadir, filename)) for filename in os.listdir(tsinghuadir)])
    CertList = pd.DataFrame({'count': data[data.label == 'white'].groupby(["Cert"]).size()}).reset_index()['Cert']
    black = data[~data['Cert'].isin((CertList))][data['label']=='black']
    white = data[data['label']=='white']
    data_tsinghua = data_tsinghua[data['Cert'].isin((CertList))]
    # print(len(white),len(black))
    data = pd.concat([black,white])
    data.dropna(inplace=True)
    extraKeys = ['Cert', 'ServerCipherSuite', 'ClientCipherSuite', 'keyID', 'Domain', 'ServerIP', 'family']
    for key in extraKeys:
        del (data[key])
        if key in data_tsinghua:
            del (data_tsinghua[key])
    print('cert filtered has %d white and %d black'%(len(data[data['label']=='white']),len(data[data['label']=='black'])))
    data = data.drop_duplicates()

    data_tsinghua['label'] = 'white'
    print(len(data[data['label']=='black']),len(data[data['label']=='white']),len(data_tsinghua))
    X = data #pd.concat([data, data_tsinghua])
    print(len(X[X['label']=='black']),len(X[X['label']=='white']))
    label = X['label'].map(lambda x: 0 if x=='white' else 1)
    X.to_csv('temp_train.csv')
    del (X['label'])
    
    return X,label

def makeModel(x_train,y_train):
    train_data=lgb.Dataset(x_train,label=y_train)

    param = {'num_leaves':150, 'objective':'binary','max_depth':7,'learning_rate':.05,'max_bin':200}
    param['metric'] = ['auc']

    num_round=50
    lgbm=lgb.train(param,train_data,num_round)
    return lgbm

def checkModel(model,x_test,y_test):
    y_pred = model.predict(x_test)
    for i in range(len(y_pred)):       
        if y_pred[i]>=.5:       # setting threshold to .5
            y_pred[i]=1
        else:  
            y_pred[i]=0

    #calculating accuracy
    accuracy_lgbm = accuracy_score(y_pred,y_test)
    print(accuracy_lgbm)
   
    auc_lgbm =  roc_auc_score(y_test,y_pred)
    print(auc_lgbm)

    print(metrics.confusion_matrix(y_test, y_pred))

def test():
    # x= pd.read_csv('temp_train.csv')
    # y = x['label'].map(lambda x: 0 if x=='white' else 1)
    # del (x['label'])
    x,y = loadTrain()
    x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=.1)
    model = makeModel(x_train,y_train)
    checkModel(model,x_test,y_test)
    saveModel(x,y)

def saveModel(x,y):
    model = makeModel(x,y)
    joblib.dump(model, 'lightgbm.model')
    cmd = 'scp lightgbm.model root@166.111.9.169:/home/CryptFlowDetection/lightgbm.model'
    os.system(cmd)


if __name__=='__main__':
    test()
