
import keras
import numpy as np

from keras.layers import Dense, LSTM
from keras.utils import to_categorical
from keras.models import Sequential
from keras.models import load_model
from keras.callbacks import ModelCheckpoint
from keras.utils.np_utils import to_categorical
from keras.layers import Masking, Embedding, Flatten
from sklearn import preprocessing

import os
import pandas as pd

le = preprocessing.LabelEncoder()
from config import  apilist

sequenceLength = 5000
nb_lstm_outputs = 30  # 神经元个数
nb_time_steps = sequenceLength  # 时间序列长度

modelname = 'thread_lstm_model.h5'
outClasses = 6
apilen = len(apilist)
nb_input_vector = apilen


def str2list(apistr):
    result = eval(apistr)
    return result


def loadData():
    df = pd.read_csv('/home/malware/malwaretc/thread_list.csv')
    df = df.iloc[0:20000, :]
    y = df['label']
    le.fit(y)
    encoded_y = le.transform(y)
    Y = to_categorical(encoded_y)
    result = []
    le.fit(range(len(apilist)))
    for behaviour in list(df['apilist']):
        tempx = []
        bList = str2list(behaviour)
        for x in bList:
            tempx.append(to_categorical(int(x), apilen))
        result.append(tempx)
        # tempList = []
        # for x in bList:
        #     now = int(x)
        #     if len(tempList)>1 and tempList[-1]==now and tempList[-2]==now:
        #         continue
        #     else:
        #         tempList.append(now)
        # result.append(tempList)
    # result.append([float(x) t])
    X = keras.preprocessing.sequence.pad_sequences(result, maxlen=sequenceLength, dtype='int32', value=-1)
    X = X.reshape(len(result), sequenceLength, apilen)
    return X, Y


def checkData():
    x, y = loadData()
    model = Sequential()
    model.add(Masking(mask_value=-1, input_shape=(sequenceLength, apilen)))

    print(x.shape, nb_lstm_outputs, nb_time_steps, nb_input_vector)
    model.add(LSTM(units=nb_lstm_outputs, input_shape=(nb_time_steps, nb_input_vector)))
    # model.add(Flatten())
    model.add(Dense(outClasses, activation='softmax'))

    model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
    modelcheck = ModelCheckpoint(filepath=modelname)

    model.fit(x, y, epochs=30, batch_size=128, verbose=1, callbacks=[modelcheck])


checkData()